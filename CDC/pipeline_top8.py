#!/usr/bin/env python3
"""
pipeline_top8.py
Produce publication-ready plots limited to top 8 industries (by average output).
This uses the same cleaned/derived CSVs generated by pipeline_full.py if present;
if not present, it will perform cleaning and computing itself.
"""

import os
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from utils import read_and_clean_csv, ensure_output_dir, compute_derived_metrics, align_dataframes

INPUT_FILES = {
    "compensation": "Space Economy Compensation by Industry.csv",
    "gross_output": "Real Gross Output by Industry.csv",
    "value_added": "Real Value Added by Industry.csv",
    "employment": "Space Economy Employment by Industry.csv"
}

OUT_DIR = "outputs/top8"
ensure_output_dir(OUT_DIR)

TOP_N = 8
sns.set(style="whitegrid")  # Seaborn style


def abbreviate_industry(name, max_words=4):
    """Abbreviate long industry names for legend."""
    words = name.strip().split()
    if len(words) > max_words:
        return ' '.join(words[:2]) + '...'  # keep first 2 words and add ellipsis
    return name.strip()


def save_line_plot(df, title, ylabel, out_path):
    """
    Plot a DataFrame (industries x years) as a line plot.
    Automatically abbreviates long legend labels.
    """
    # Abbreviate industries if necessary
    df = df.copy()
    df.index = [abbreviate_industry(i) for i in df.index]

    plt.figure(figsize=(16, 9))  # larger figure for legibility
    ax = sns.lineplot(data=df.T, marker='o', linewidth=2.5)

    ax.set_title(title, fontsize=20)
    ax.set_xlabel("Year", fontsize=16)
    ax.set_ylabel(ylabel, fontsize=16)

    # Legend outside plot, smaller font
    ax.legend(title="Industry", bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10, title_fontsize=12)

    # Adjust layout to avoid warnings
    plt.tight_layout()
    plt.subplots_adjust(right=0.75, bottom=0.15, top=0.9)

    # Save figure
    plt.savefig(out_path, bbox_inches='tight', dpi=300)
    plt.close()


def main():
    # Read files
    dfs = {}
    for key, fname in INPUT_FILES.items():
        if Path(fname).exists():
            dfs[key] = read_and_clean_csv(fname)
        else:
            print(f"Warning: {fname} not found and will be skipped if not needed.")

    # Validate required files
    if "compensation" not in dfs or "employment" not in dfs or (("gross_output" not in dfs) and ("value_added" not in dfs)):
        raise SystemExit("ERROR: Need compensation, employment, and either gross_output or value_added files present.")

    output_key = "gross_output" if "gross_output" in dfs else "value_added"
    subset = {k: dfs[k] for k in ["compensation", "employment", output_key]}
    subset_aligned, common_years = align_dataframes(subset)

    # Compute derived metrics
    derived = compute_derived_metrics(subset_aligned["compensation"],
                                      subset_aligned["employment"],
                                      subset_aligned[output_key])

    # Top N industries by mean output
    mean_output = subset_aligned[output_key].mean(axis=1).sort_values(ascending=False)
    top_inds = mean_output.index[:TOP_N].tolist()
    print("Top industries selected:", top_inds)

    # Subset derived metrics
    derived_top = {k: v.loc[top_inds] for k, v in derived.items()}

    # Produce plots
    save_line_plot(derived_top["labor_hoarding_diff"],
                   title=f"Labor Hoarding (%ΔEmp - %ΔOut) — Top {TOP_N} Industries",
                   ylabel="Percentage points",
                   out_path=os.path.join(OUT_DIR, f"labor_hoarding_diff_top{TOP_N}.png"))

    save_line_plot(derived_top["labor_hoarding_ratio"],
                   title=f"Labor Hoarding Ratio — Top {TOP_N} Industries",
                   ylabel="Percent",
                   out_path=os.path.join(OUT_DIR, f"labor_hoarding_ratio_top{TOP_N}.png"))

    save_line_plot(derived_top["wage_inflation"],
                   title=f"Wage Inflation (YoY % avg comp) — Top {TOP_N} Industries",
                   ylabel="Percent",
                   out_path=os.path.join(OUT_DIR, f"wage_inflation_top{TOP_N}.png"))

    # Save top-N CSVs
    for name, df in derived_top.items():
        df.to_csv(os.path.join(OUT_DIR, f"{name}_top{TOP_N}.csv"))

    print("Top-8 pipeline complete. Outputs in:", os.path.abspath(OUT_DIR))


if __name__ == "__main__":
    main()
